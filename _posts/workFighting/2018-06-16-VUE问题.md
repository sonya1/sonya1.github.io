---
layout: post
title: VUE问题
category: workFighting
tags: vue
description: 
---

## 1.请详细说下你对vue生命周期的理解？
答：Vue实例从创建到销毁的过程，就是生命周期。

![图1](https://cn.vuejs.org/images/lifecycle.png)

总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后。

### 创建前/后： 
在beforeCreate阶段，vue实例的挂载元素$el和数据对象data都为undefined，还未初始化。

在created阶段，vue实例的数据对象data有了，$el还没有。

###  载入前/后：
在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。

在mounted阶段，vue实例挂载完成，data.message成功渲染。

### 更新前/后：
当data变化时，会触发beforeUpdate和updated方法。

### 销毁前/后：
在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在.

```vue
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <div id="app">
        <aaa></aaa>
    </div>

    
    <template id="aaa">
        <div>
            <p class="myp">A组件</p>
            <button @click="destroy">destroy</button>
            <input type="text" v-model="msg">
            <p>msg:{{msg}}</p>
        </div>
    </template>



</body>
<script src="./vue.js"></script>

<script>
//生命周期：初始化阶段 运行中阶段 销毁阶段
Vue.component("aaa",{
    template:"#aaa",
    data:function(){
        return {msg:'hello'}
    },
    timer:null,
    methods:{
        destroy:function(){
            this.$destroy()//
        }
    },
    beforeCreate:function(){
        console.log('beforeCreate:刚刚new Vue()之后，这个时候，数据还没有挂载呢，只是一个空壳')           
        console.log(this.msg)//undefined
        console.log(document.getElementsByClassName("myp")[0])//undefined
    },
    created:function(){
        console.log('created:这个时候已经可以使用到数据，也可以更改数据,在这里更改数据不会触发updated函数')
        this.msg+='!!!'
        console.log('在这里可以在渲染前倒数第二次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取')
        console.log('接下来开始找实例或者组件对应的模板，编译模板为虚拟dom放入到render函数中准备渲染')
    },
    beforeMount:function(){
        console.log('beforeMount：虚拟dom已经创建完成，马上就要渲染,在这里也可以更改数据，不会触发updated')
        this.msg+='@@@@'
        console.log('在这里可以在渲染前最后一次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取')
        console.log(document.getElementsByClassName("myp")[0])//undefined
        console.log('接下来开始render，渲染出真实dom')
    },
    // render:function(createElement){
    //     console.log('render')
    //     return createElement('div','hahaha')
    // },
    mounted:function(){ 
        console.log('mounted：此时，组件已经出现在页面中，数据、真实dom都已经处理好了,事件都已经挂载好了')
        console.log(document.getElementsByClassName("myp")[0])
        console.log('可以在这里操作真实dom等事情...')

    //    this.$options.timer = setInterval(function () {
    //        console.log('setInterval')
    //         this.msg+='!'  
    //    }.bind(this),500)
    },
    beforeUpdate:function(){
        //这里不能更改数据，否则会陷入死循环
        console.log('beforeUpdate:重新渲染之前触发')
        console.log('然后vue的虚拟dom机制会重新构建虚拟dom与上一次的虚拟dom树利用diff算法进行对比之后重新渲染')         
    },
    updated:function(){
        //这里不能更改数据，否则会陷入死循环
        console.log('updated:数据已经更改完成，dom也重新render完成')
    },
    beforeDestroy:function(){
        console.log('beforeDestory:销毁前执行（$destroy方法被调用的时候就会执行）,一般在这里善后:清除计时器、清除非指令绑定的事件等等...')
        // clearInterval(this.$options.timer)
    },
    destroyed:function(){
        console.log('destroyed:组件的数据绑定、监听...都去掉了,只剩下dom空壳，这里也可以善后')
    }
})

new Vue({
}).$mount('#app')

</script>
</html>
```

## 2.Vue组件通信的方式

答:组件关系有下面三种：父-->子、子-->父、非父子

### (1) 父->子

父向子传递数据通过props

```vue
**父组件代码**
<template>
    <header-box :title-txt="showTitleTxt"></header-box>
</template>
<script>
  import Header from './header'
  export default {
      name: 'index',
      components: {
          'header-box': Header
      },
      data () {
          return {
              showTitleTxt: '首页'
          }
      }
  }
</script>
```

```vue
**子组件代码**
<template>
    <header>
        {{thisTitleTxt}}
    </header>
</template>
<script>
    export default {
        name: 'header-box',
        props: {
            titleTxt: String
        },
        data () {
            return {
                thisTitleTxt: this.titleTxt
            }
        }
    }
</script>
```

### (2) 子-->父

子组件向父组件传递分为两种类型:

1、子组件改变父组件传递的props（你会发现通过props中的Object类型参数传输数据，可以通过子组件改变数据内容。这种方式是可行的，但是不推荐使用，因为官方定义prop是单向绑定）

2、通过$on和$emit

```vue
*通过props实现传递*
**父组件代码**
<template>
    <header-box :title-txt="showTitleTxt"></header-box>
</template>
<script>
    import Header from './header'
    export default {
        name: 'index',
        components: {
            'header-box': Header
        },
        data () {
            return {
                showTitleTxt: {
                    name: '首页'
                }
            }
        }
    }
</script>
```

```vue
**子组件代码**
<template>
    <header @click="changeTitleTxt">
        {{thisTitleTxt.name}}
    </header>
</template>
<script>
    export default {
        name: 'header-box',
        props: {
            titleTxt: Object
        },
        data () {
            return {
                thisTitleTxt: this.titleTxt.name
            }
        },
        metheds: {
            changeTitleTxt () {
                this.titleTxt.name = '切换'
            }
        }
    }
</script>
```

```vue
*通过$on,$emit*
**父组件代码**
<template>
    <div id="counter-event-example">
      <p>{{ total }}</p>
      <button-counter v-on:increment="incrementTotal"></button-counter>
</div>
</template>
<script>
    import ButtonCounter from './buttonCounter'
    export default {
        name: 'index',
        components: {
            'button-conuter': ButtonCounter
        },
        data () {
            return {
                total: 0
            }
        },
        methods: {
            incrementTotal () {
                this.total++
            }
        }
    }
</script>
```

```vue
**子组件代码**
<template>
    <button @click="incrementCounter">{{counter}}</button>
</template>
<script>
    export default {
        name: 'button-counter',
        data () {
            return {
                counter: 0
            }
        },
        metheds: {
            incrementCounter () {
                this.$emit('increment')
                this.counter++
            }
        }
    }
</script>
```

### (3)非父子

简单情况下我们可以通过使用一个空的Vue实例作为中央事件总线
```vue
**main.js**
let bus = new Vue()
Vue.prototype.bus = bus
```

```vue
**header组件**
<template>
    <header @click="changeTitle">{{title}}</header>
</template>
<script>
export default {
    name: 'header',
    data () {
        return {
            title: '头部'
        }
    },
    methods: {
        changeTitle () {
            this.bus.$emit('toChangeTitle','首页')
        }
    }
}
</script>
```

```vue
**footer组件**
<template>
    <footer>{{txt}}</footer>
</template>
<script>
export default {
    name: 'footer',
    mounted () {
        this.bus.$on('toChangeTitle', function (title) {
            console.log(title)
        })
    },
    data () {
        return {
            txt: '尾部'
        }
    }
}
```

## 3.Vue的双向数据绑定原理是什么？
首先我们应该搞清楚什么是数据劫持，说白了就是通过Object.defineProperty()来劫持对象属性的setter和getter操作，在数据变动时做你想要做的事情.

实现mvvm主要包含两个方面，数据变化更新视图，视图变化更新数据.

答：vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。

具体步骤：
第一步：需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter

这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化

第二步：compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图

第三步：Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:

1、在自身实例化时往属性订阅器(dep)里面添加自己

2、自身必须有一个update()方法

3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。

第四步：MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果。

ps：答案同样适合”vue data是怎么实现的？”此面试题。

参考：[vue问题](https://segmentfault.com/a/1190000012315822)

好文：[vue数据双向绑定原理](http://www.cnblogs.com/libin-1/p/6893712.html)
